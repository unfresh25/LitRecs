[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "LitRecs (Literature Recommendations)",
    "section": "",
    "text": "Welcome to LitRecs, an app designed for book lovers who want to keep track of their reading and discover new works that match their tastes. Inspired by platforms like Goodreads, LitRecs offers a comprehensive and personalized experience for managing your personal library and exploring new recommendations."
  },
  {
    "objectID": "index.html#main-features",
    "href": "index.html#main-features",
    "title": "LitRecs (Literature Recommendations)",
    "section": "Main Features",
    "text": "Main Features\n\nBook Search: Find books by title, author, genre, or keyword.\nReading Management: Mark the books you’re reading, have read, and want to read.\nRatings and Reviews: Rate books and write detailed reviews to share your opinions with other users.\nPersonalized Recommendations: Get recommendations based on your previous readings and ratings through machine learning algorithms.\nUser-Friendly Interface: Enjoy an intuitive and easy-to-use interface designed to enhance your user experience."
  },
  {
    "objectID": "index.html#why-litrecs",
    "href": "index.html#why-litrecs",
    "title": "LitRecs (Literature Recommendations)",
    "section": "Why LitRecs?",
    "text": "Why LitRecs?\nIn a world full of books to discover, LitRecs becomes your best ally in finding reads that truly excite you. Our goal is to simplify the process of searching for and selecting books, while providing you with tools to keep a detailed record of your reading habits. With LitRecs, you don’t just read; you also become part of a community that values literature as much as you do.\nWe hope you enjoy using LitRecs as much as we enjoyed developing it!"
  },
  {
    "objectID": "guides/index.html",
    "href": "guides/index.html",
    "title": "Guide",
    "section": "",
    "text": "Important\n\n\n\nNote that some functionalities are omitted in this article, as they are intuitive based on the explanations provided throughout this chapter.\n\n\nIn our process of extracting book data, we use two different methods. One method involves acquiring data for books not already in our database. For this, we use the freely available OpenLibrary API, provided by the largest digital library on the internet, the Internet Archive. You can explore the OpenLibrary website by clicking here, although we will cover the important aspects of using it throughout this chapter.\n\n\n\nOpenLibraryAPI Website\n\n\nThe other method involves retrieving books already registered in our database. We use a PostgreSQL database hosted on Neon. This approach ensures that books not stored in the database are fetched using the OpenLibrary API, processed, and uploaded to the database for future searches. It also helps us keep our data centralized. Searching for books in our database is faster than fetching data from an API, which could change or be removed in the future.\n\n\n\nNeon Website",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Get Started",
    "section": "",
    "text": "How to get started\nYou can get the application’s code by cloning the repository to your computer as follows:\n\nClone the Repository: Open your terminal and clone the repository using git clone https://github.com/unfresh25/LitRecs.git.\nInstall Dependencies: Navigate to the project directory and install the dependencies listed in the requirements.txt file by running cd LitRecs && pip install -r requirements.txt in the terminal.\nExplore and Develop: Review the files using your preferred code editor and start building your own recommendation system.\n\n\n\nContributions\nTo contribute, you need to request access to the database to obtain the necessary information about the books. Apart from that, we welcome contributions from the community. Any creativity, development, or bug fixes are greatly appreciated. Therefore, don’t hesitate to open an issue or send a PR once you’ve gained access."
  },
  {
    "objectID": "guides/extracting-data.html",
    "href": "guides/extracting-data.html",
    "title": "OpenLibrary API",
    "section": "",
    "text": "To acquire data for books not already registered in our database, we use the freely available OpenLibrary API. This resource offers a variety of APIs for different purposes, such as:\n\nSearching for books, authors, and more.\nFetching books by subject name.\nSearching for matching text.\nRetrieving book covers by ISBN or OpenLibrary identifier.\n\nIn this project, we will use some of these APIs, so please refer to this guide as needed.\n\nRequired Libraries\nFirst, we need to import several libraries for our project:\n\npsycopg2\npandas\npython-dotenv\nrequests\nos\n\nLet’s load these libraries:\n\nimport psycopg2 as psy\nfrom psycopg2 import Error\n\nimport pandas as pd\nfrom dotenv import load_dotenv\nimport os\nimport requests\n\n\n\nFetching Book Information\nHere’s how to fetch information about a book using a function that retrieves books based on user requests:\n\ndef search_book_by_title(title):\n    url = \"https://openlibrary.org/search.json\"\n    params = {\n        'title': title,\n        'limit': 20\n    }\n    response = requests.get(url, params=params)\n    if response.status_code == 200:\n        data = response.json()\n        return data['docs']\n    else:\n        print(\"Error connecting to OpenLibrary API\")\n        return []\n\nFor example, we will search for Animal Farm by George Orwell:\n\ntitle = \"Animal Farm\"\nbooks = search_book_by_title(title)\n\nThis code calls our search function and retrieves books related to the requested title. The response data is extensive, so let’s extract some key information:\n\nbooks_df = []\n\nfor book in books:\n    title = book.get('title')\n    author_list = book.get('author_name', ['Author not available'])\n    author = author_list[0] if author_list else 'Author not available'\n    year = book.get('first_publish_year', 'Year not available')\n    isbn_list = book.get('isbn', ['ISBN not available'])\n    isbn = isbn_list[0] if isbn_list else 'ISBN not available'\n    \n    books_df.append([title, author, year, isbn])\n\nbooks_df = pd.DataFrame(books_df, columns=['Title', 'Author', 'Year', 'ISBN'])\nshow(books_df, ordering = False, searching = False)\n\n\n\n    \n      \n      Title\n      Author\n      Year\n      ISBN\n    \n  \n\n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n\n\nLoading ITables v2.1.1 from the internet...\n(need help?)\n\n\n\n\n\n\n\n\n\nThis code compiles important information such as the book’s title, author, publication year, and ISBN. The OpenLibrary API also provides additional data about the book cover, language, editions, number of pages, publisher, genres, and more, which we will explore further in subsequent sections.\n\n\nLooking for important data\nIn the previous section, we obtained relevant data about the books. However, to get other necessary information, we need to use another endpoint that takes the book edition ID as a parameter. This means first performing a search with the previous endpoint and then using the new endpoint located at https://openlibrary.org/works/{key}.json. An example of the results obtained through this endpoint can be seen here.\nTo obtain this data, we will first use the initial endpoint to extract the edition codes and then use the second endpoint as follows:\n\nbook_keys = []\n\nfor book in books:\n    edition_key = book.get('key', '')\n    book_keys.append(edition_key)\n\nbook_keys[0:5]\n\n['/works/OL1168007W',\n '/works/OL1167981W',\n '/works/OL1703970W',\n '/works/OL1168159W',\n '/works/OL36114077W']\n\n\nNow that we have the edition codes, we can define our function to call the next endpoint as follows:\n\ndef search_book_by_ed_key(key):\n    url = f\"https://openlibrary.org{key}.json\"\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        data = response.json()\n        return data\n    else:\n        print(\"Error connecting to OpenLibrary API\")\n        return []\n\nWe call the function and extract the relevant data, keeping in mind that key corresponds to the edition codes identified earlier:\n\nbooks_df = []\n\nfor key in book_keys:\n    data = search_book_by_ed_key(key)\n\n    title = data.get('title', '')\n    subjects_v = data.get('subjects', [])[0:4]\n    subjects = ', '.join(subjects_v)\n    description = data.get('description', 'No description available')\n\n    books_df.append([title, subjects, description])\n\nbooks_df = pd.DataFrame(books_df, columns=['Title', 'Subjects', 'Description'])\nshow(books_df, ordering=False, searching=False)\n\n\n\n    \n      \n      Title\n      Subjects\n      Description\n    \n  \n\n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n\n\nLoading ITables v2.1.1 from the internet...\n(need help?)\n\n\n\n\n\n\n\n\n\n\nFetching whole data\nNow that we understand how to obtain the essential information and how the OpenLibrary API works, we can proceed to gather all the necessary data to store in our database. The required data are as follows:\n\nbook_id (key)\ntitle\nauthor\ndescription\nfirst_publish_year\ncover_medium\ncover_large\naverage_rating\nrating_count\n\nTo do this, we will define the following functions:\n\n\n\n\n\n\nNote\n\n\n\nTo obtain the book covers, we will use the cover_i, which corresponds to the ID of the covers associated with each registered book. For more information, you can consult the documentation here.\n\n\n\nclass OpenLibraryClient:\n    def __init__(self):\n        self.base_url = \"https://openlibrary.org\"\n    \n    def get_book_info(self, title, limit=20):\n        url = f\"{self.base_url}/search.json\"\n        params = {\n            'title': title,\n            'limit': limit\n        }\n        response = requests.get(url, params=params)\n        if response.status_code == 200:\n            data = response.json()\n            return data['docs']\n        else:\n            print(\"Error connecting to OpenLibrary API\")\n            return []\n\n    def get_book_description(self, key):\n        url = f\"{self.base_url}{key}.json\"\n        response = requests.get(url)\n\n        if response.status_code == 200:\n            data = response.json()\n            return data\n        else:\n            print(\"Error connecting to OpenLibrary API\")\n            return {}\n\n    def fetch_books(self, title):\n        books = self.get_book_info(title)\n        books_data = []\n        for book in books:\n            book_id = book.get('key', '')\n            title = book.get('title', 'No title available')\n\n            author_list = book.get('author_name', ['Author not available'])\n            author = author_list[0] if author_list else 'Author not available'\n\n            description = self.get_book_description(book_id).get('description', 'No description available')\n            year = book.get('first_publish_year', 'Year not available')\n\n            cover_i = book.get('cover_i', '')\n            cover_m = f'https://covers.openlibrary.org/b/id/{cover_i}-M.jpg'\n            cover_l = f'https://covers.openlibrary.org/b/id/{cover_i}-L.jpg'\n\n            avg_r = book.get('ratings_average', 0)\n            r_count = book.get('ratings_count', 0)\n            \n            books_data.append({\n                'book_id': book_id,\n                'title': title,\n                'author': author,\n                'description': description,\n                'year': year,\n                'cover_m': cover_m,\n                'cover_l': cover_l,\n                'avg_r': round(avg_r, 2),\n                'r_count': r_count\n            })\n        return books_data\n\nclient = OpenLibraryClient()\nbooks = client.fetch_books(\"Throne Of Glass\")\n\nbooks_df = pd.DataFrame(books)\nshow(books_df, ordering=False, searching=False)\n\n\n\n    \n      \n      book_id\n      title\n      author\n      description\n      year\n      cover_m\n      cover_l\n      avg_r\n      r_count\n    \n  \n\n\n\n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n\n\nLoading ITables v2.1.1 from the internet...\n(need help?)\n\n\n\n\n\n\n\n\n\nIn this case, we do not display the description in the table due to the space it would occupy. However, it is a crucial piece of data, so we should always collect it whenever possible.\nWhen a user searches for books that are already registered, we retrieve them from a PostgreSQL database hosted on Neon. This ensures that any books not found in the database are fetched using the OpenLibrary API, processed, and uploaded to the database for future searches. Since this guide focuses on processing books and making recommendations, we’ll skip the detailed steps of querying and updating the database. Instead, we’ll concentrate on generating recommendations based on searches, reading history, and friends’ books.",
    "crumbs": [
      "Guide",
      "OpenLibrary API"
    ]
  },
  {
    "objectID": "guides/search-recommendations.html",
    "href": "guides/search-recommendations.html",
    "title": "Search recommendations",
    "section": "",
    "text": "In this section, we will discuss recommendations offered to users based on their searches or the book they input to gather information. Specifically, we will explore recommendations known as “you might also like this”.\nTo perform these tasks, we will first load the necessary libraries for data retrieval and processing:\nimport os\nfrom dotenv import load_dotenv\n\nimport psycopg2 as psy\nfrom sqlalchemy import create_engine, text\n\nimport pandas as pd\nimport re\n\nload_dotenv()\n\nDATABASE_URL = os.getenv('DATABASE_URL')\n\nengine = create_engine(DATABASE_URL)\nIt’s important to note that DATABASE_URL is simply the connection link to our database on Neon.\nFor this section, we’ll use the sqlalchemy, psycopg2, and pandas libraries to access the database, which in our case is PostgreSQL. If you are using a different type of database, you will need to adjust the libraries accordingly.\nLet’s start by creating a function to search for specific books:\ndef search_book(search):\n    search = re.sub(r'\\s+', \" \", search).replace(\" \", \" & \")\n    print(f'Results for: {search}')\n    print()\n\n    query = text(\"\"\"\n        SELECT title, author, genres\n        FROM books\n        WHERE con_info @@ to_tsquery(:search)\n        LIMIT 3;\n    \"\"\")\n\n    with engine.connect() as conn:\n        result = conn.execute(query, {'search': search})\n        return result.fetchall()\nThis function searches our database for user-entered keywords and returns the titles, authors, and genres of the books found with the requested characteristics.",
    "crumbs": [
      "Guide",
      "Search Recommendations"
    ]
  },
  {
    "objectID": "guides/search-recommendations.html#search-by-title",
    "href": "guides/search-recommendations.html#search-by-title",
    "title": "Search recommendations",
    "section": "Search by Title",
    "text": "Search by Title\nSuppose a user wants to search for the “Throne of Glass” series by author Sarah J. Maas. The results would be as follows:\n\nbooks = search_book('throne     of Glass')\nfor book in books:\n    print(f'Title: {book.title}')\n    print(f'Author: {book.author}')\n    print(f'Genres:')\n    genres = book.genres.replace('[', '').replace(']', '').replace(\"'\", \"\").split(', ')\n    for genre in genres:\n        print(f'- {genre.capitalize()}')\n    print()\n\nResults for: throne & of & Glass\n\nTitle: Throne of Glass\nAuthor: Sarah J. Maas\nGenres:\n- Courts and courtiers\n- Juvenile fiction / love & romance\n- Prisoners\n- Assassins\n- Princes\n\nTitle: The Assassin’s Blade\nAuthor: Sarah J. Maas\nGenres:\n- Fiction\n- Collections & anthologies\n- Young adult fiction\n- Dark fantasy\n- Fantasy\n- Female assassins in fiction\n- Fantasy\n- Series:throne_of_glass\n\nTitle: World of Throne of Glass\nAuthor: Sarah J. Maas\nGenres:\n- Literature\n- Fiction\n- History and criticism\n- Juvenile literature",
    "crumbs": [
      "Guide",
      "Search Recommendations"
    ]
  },
  {
    "objectID": "guides/search-recommendations.html#search-by-author",
    "href": "guides/search-recommendations.html#search-by-author",
    "title": "Search recommendations",
    "section": "Search by Author",
    "text": "Search by Author\nIf the user wants to search for all books by a specific author, such as Sarah J. Maas, the search would be conducted as follows:\n\nbooks = search_book('Sarah J. Maas')\nfor book in books:\n    print(f'Title: {book.title}')\n    print(f'Author: {book.author}')\n    print(f'Genres:')\n    genres = book.genres.replace('[', '').replace(']', '').replace(\"'\", \"\").split(', ')\n    for genre in genres:\n        print(f'- {genre.capitalize()}')\n    print()\n\nResults for: Sarah & J. & Maas\n\nTitle: Throne of Glass\nAuthor: Sarah J. Maas\nGenres:\n- Courts and courtiers\n- Juvenile fiction / love & romance\n- Prisoners\n- Assassins\n- Princes\n\nTitle: The Assassin’s Blade\nAuthor: Sarah J. Maas\nGenres:\n- Fiction\n- Collections & anthologies\n- Young adult fiction\n- Dark fantasy\n- Fantasy\n- Female assassins in fiction\n- Fantasy\n- Series:throne_of_glass\n\nTitle: World of Throne of Glass\nAuthor: Sarah J. Maas\nGenres:\n- Literature\n- Fiction\n- History and criticism\n- Juvenile literature",
    "crumbs": [
      "Guide",
      "Search Recommendations"
    ]
  },
  {
    "objectID": "guides/search-recommendations.html#search-by-keywords",
    "href": "guides/search-recommendations.html#search-by-keywords",
    "title": "Search recommendations",
    "section": "Search by Keywords",
    "text": "Search by Keywords\nFinally, even if the user doesn’t know the specific title or author, they can search for books using keywords like “fantasy young adult romance”. The process to retrieve results would be similar:\n\nbooks = search_book('fantasy young adult romance')\nfor book in books:\n    print(f'Title: {book.title}')\n    print(f'Author: {book.author}')\n    print(f'Genres:')\n    genres = book.genres.replace('[', '').replace(']', '').replace(\"'\", \"\").split(', ')\n    for genre in genres:\n        print(f'- {genre.capitalize()}')\n    print()\n\nResults for: fantasy & young & adult & romance\n\nTitle: Vampire Academy\nAuthor: Richelle Mead\nGenres:\n- Young adult\n- Collectionid:eaneschallenge\n- Romance\n- Urban fantasy\n\nTitle: Broken Throne\nAuthor: Victoria Aveyard\nGenres:\n- General\n- Collections & anthologies\n- Young adult fiction\n- Romance\n- Fantasy\n- Royalty\n- Short stories\n\nTitle: Serpent and Dove\nAuthor: Shelby Mahurin\nGenres:\n- Wizards & witches\n- Paranormal\n- Nyt:young-adult-hardcover=2019-09-22\n- Young adult fiction\n- Romance\n- Fantasy\n- New york times bestseller",
    "crumbs": [
      "Guide",
      "Search Recommendations"
    ]
  },
  {
    "objectID": "guides/search-recommendations.html#recommendations-by-search",
    "href": "guides/search-recommendations.html#recommendations-by-search",
    "title": "Search recommendations",
    "section": "Recommendations by search",
    "text": "Recommendations by search\nNow, as we mentioned initially, we will work on user recommendations based on their search. In other words, in addition to showing the user the books obtained from their search, the application will display a “you might like this” section with some books related to their search.\nTo implement this, we will create the following function to perform queries on the database:\n\ndef rec_by_search(search):\n    search = re.sub(r'\\s+', \" \", search)\n\n    query = text(\"\"\"\n        SELECT DISTINCT(title), author, first_publish_year AS year, cover_m AS cover,\n        similarity(con_info::text, (SELECT con_info::text FROM books WHERE title = :title LIMIT 1)) AS similarity\n        FROM books\n        WHERE title != :title\n        ORDER BY similarity DESC\n        LIMIT 5;\n    \"\"\")\n\n    with engine.connect() as conn:\n        result = conn.execute(query, {'title': search})\n        return result.fetchall()\n\nLet’s test the function using the following book as an example: “The Assassin’s Blade”:\n\nbooks = rec_by_search('The Assassin’s Blade')\nbooks = pd.DataFrame(books)\nshow(books.style.format({'cover': show_image}), ordering=False, searching=False)\n\n\n\n\n\n\n\ntitle\nauthor\nyear\ncover\nsimilarity\n\n\n\n\nThe Assassin and the Empire\nSarah J. Maas\n2012\n\n0.502584\n\n\nTower of Dawn\nSarah J. Maas\n2017\n\n0.483982\n\n\nThe Shadow Queen (Ravenspire Series, Book 1)\nC. J. Redwine\n2016\n\n0.482846\n\n\nHowl's Moving Castle (Howl's Moving Castle #1)\nDiana Wynne Jones\n1986\n\n0.481818\n\n\nA Court of Thorns and Roses\nSarah J. Maas\n2015\n\n0.478261\n\n\n\n\n\n\n\n\n\n\nNote that this function will be used when a user clicks to view detailed information about a book obtained from their search.",
    "crumbs": [
      "Guide",
      "Search Recommendations"
    ]
  }
]